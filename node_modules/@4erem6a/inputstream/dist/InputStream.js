"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Class for traversing and analyzing strings.
 */
class InputStream {
    /**
     * @param source The source string.
     */
    constructor(source) {
        this.source = source;
        /**
         * Current position in the source string.
         */
        this.position = 0;
    }
    /**
     * The length of the source string.
     */
    get length() {
        return this.source.length;
    }
    /**
     * Returns the current character from the source string.
     * @param offset The offset relative to the current position.
     */
    peek(offset = 0) {
        return this.checkBounds(offset) ? this.source[this.position + offset] : "";
    }
    /**
     * Returns the source substring of the specified length staring from current position with an offset.
     * @param length The number of characters to peek.
     * @param offset The offset relative to the current position.
     */
    peekMany(length, offset = 0) {
        return this.source.substr(this.position + offset, length);
    }
    /**
     * Returns the source substring from the current position to the specified one.
     * The substring includes the characters up to, but not including, the character indicated by end.
     * @param end The zero-based index number to peek to.
     * If this value is not specified, the substring continues to the end of the source string.
     * @param offset The offset relative to the current position
     */
    peekTo(end, offset = 0) {
        return this.source.substring(this.position + offset, end);
    }
    /**
     * Returns a section of the source string.
     * @param start The index to the beginning of the specified portion of the source string.
     * @param end The index to the end of the specified portion of the source string.
     * The substring includes the characters up to, but not including, the character indicated by end.
     * If this value is not specified, the substring continues to the end of the source string.
     */
    slice(start, end) {
        return this.source.slice(start, end);
    }
    /**
     * The current character.
     */
    get current() {
        return this.peek(0);
    }
    /**
     * The next character.
     */
    get next() {
        return this.peek(1);
    }
    /**
     * The substring from the current position to the end of the source string.
     */
    get rest() {
        return this.peekTo();
    }
    /**
     * Adjusts the current position by the specified value.
     * @param offset The offset to move by.
     * @returns New position.
     */
    move(offset) {
        return (this.position += offset);
    }
    /**
     * Sets the current position.
     * @param position The new position.
     * @returns New position.
     */
    moveTo(position) {
        return (this.position = position);
    }
    /**
     * Sets the current position to 0.
     */
    reset() {
        this.position = 0;
    }
    /**
     * Checks whether the current position is reached the end of the source string.
     * @param offset The offset relative the current position.
     */
    checkEof(offset) {
        return this.position + offset >= this.length;
    }
    /**
     * Whether the current position is reached the end of the source string.
     */
    get isEof() {
        return this.checkEof(0);
    }
    /**
     * Checks whether the current position is within the string bounds.
     */
    checkBounds(offset) {
        const position = this.position + offset;
        return position >= 0 && !this.checkEof(offset);
    }
    /**
     * Whether the current position is within the string bounds.
     */
    get isValid() {
        return this.checkBounds(0);
    }
    /**
     * Checks whether a lexeme is present at the current position of the source string.
     * @param lexeme One or more lexemes to look for.
     * @param offset The offset relative to the current position.
     */
    lookFor(lexeme, offset = 0) {
        if (Array.isArray(lexeme)) {
            return lexeme.some(t => this.lookFor(t, offset));
        }
        else {
            return this.source.startsWith(lexeme, this.position + offset);
        }
    }
    /**
     * Matches a lexeme at the current position of the source string.
     * I.e if a lexeme is present, moves the stream by the length of the lexeme.
     * @param lexeme One or more lexemes to match.
     * @param offset The offset relative to the current position.
     * @returns Whether a lexeme was matched.
     */
    match(lexeme, offset = 0) {
        if (Array.isArray(lexeme)) {
            return lexeme.some(t => this.match(t, offset));
        }
        else {
            const matches = this.lookFor(lexeme, offset);
            if (matches) {
                this.move(lexeme.length + offset);
            }
            return matches;
        }
    }
    /**
     * Returns the first presenting lexeme, and undefined otherwise.
     * @param lexemes Lexemes to check for.
     * @param offset The offset relative to the current position.
     */
    findPresenting(lexemes, offset = 0) {
        return lexemes.find(l => this.lookFor(l, offset));
    }
    /**
     * Returns the first matched lexeme, and undefined otherwise.
     * @param lexemes Lexemes to match with.
     * @param offset The offset relative to the current position.
     */
    findMatching(lexemes, offset = 0) {
        return lexemes.find(l => this.match(l, offset));
    }
    /**
     * Checks whether a regex pattern exists in the rest of the source string.
     * @param regexp One or more regular expressions to test for.
     * @param offset The offset relative to the current position.
     */
    testFor(regexp, offset = 0) {
        if (Array.isArray(regexp)) {
            return regexp.some(re => this.testFor(re, offset));
        }
        else {
            return regexp.test(this.peekTo(undefined, offset));
        }
    }
    /**
     * Matches a regex pattern with the rest of the source string.
     * @param regexp A regular expression to match with.
     * @param offset The offset relative to the current value.
     */
    matchRegExp(regexp, offset = 0) {
        // eslint-disable-next-line @typescript-eslint/prefer-regexp-exec
        return this.peekTo(undefined, offset).match(regexp);
    }
    /**
     * The {@link SourceLocation location} of the current character.
     */
    get location() {
        const slice = this.slice(0, this.position);
        const line = slice.split("").filter(c => c == "\n").length + 1;
        const column = slice.includes("\n")
            ? slice.slice(slice.lastIndexOf("\n")).length
            : this.position + 1;
        return {
            line,
            column,
            absolute: this.position
        };
    }
    /**
     * The line containing the current character.
     */
    get currentLine() {
        const leadingLinebreak = this.slice(0, this.position).lastIndexOf("\n");
        const trailingLinebreak = this.slice(this.position).indexOf("\n");
        const line = this.slice(leadingLinebreak == -1 ? 0 : leadingLinebreak + 1, trailingLinebreak == -1 ? undefined : this.position + trailingLinebreak);
        return line;
    }
}
exports.InputStream = InputStream;
