import { SourceLocation } from "./SourceLocation";
/**
 * Class for traversing and analyzing strings.
 */
export declare class InputStream {
    readonly source: string;
    /**
     * Current position in the source string.
     */
    position: number;
    /**
     * @param source The source string.
     */
    constructor(source: string);
    /**
     * The length of the source string.
     */
    get length(): number;
    /**
     * Returns the current character from the source string.
     * @param offset The offset relative to the current position.
     */
    peek(offset?: number): string;
    /**
     * Returns the source substring of the specified length staring from current position with an offset.
     * @param length The number of characters to peek.
     * @param offset The offset relative to the current position.
     */
    peekMany(length: number, offset?: number): string;
    /**
     * Returns the source substring from the current position to the specified one.
     * The substring includes the characters up to, but not including, the character indicated by end.
     * @param end The zero-based index number to peek to.
     * If this value is not specified, the substring continues to the end of the source string.
     * @param offset The offset relative to the current position
     */
    peekTo(end?: number, offset?: number): string;
    /**
     * Returns a section of the source string.
     * @param start The index to the beginning of the specified portion of the source string.
     * @param end The index to the end of the specified portion of the source string.
     * The substring includes the characters up to, but not including, the character indicated by end.
     * If this value is not specified, the substring continues to the end of the source string.
     */
    slice(start?: number, end?: number): string;
    /**
     * The current character.
     */
    get current(): string;
    /**
     * The next character.
     */
    get next(): string;
    /**
     * The substring from the current position to the end of the source string.
     */
    get rest(): string;
    /**
     * Adjusts the current position by the specified value.
     * @param offset The offset to move by.
     * @returns New position.
     */
    move(offset: number): number;
    /**
     * Sets the current position.
     * @param position The new position.
     * @returns New position.
     */
    moveTo(position: number): number;
    /**
     * Sets the current position to 0.
     */
    reset(): void;
    /**
     * Checks whether the current position is reached the end of the source string.
     * @param offset The offset relative the current position.
     */
    checkEof(offset: number): boolean;
    /**
     * Whether the current position is reached the end of the source string.
     */
    get isEof(): boolean;
    /**
     * Checks whether the current position is within the string bounds.
     */
    checkBounds(offset: number): boolean;
    /**
     * Whether the current position is within the string bounds.
     */
    get isValid(): boolean;
    /**
     * Checks whether a lexeme is present at the current position of the source string.
     * @param lexeme One or more lexemes to look for.
     * @param offset The offset relative to the current position.
     */
    lookFor(lexeme: string | string[], offset?: number): boolean;
    /**
     * Matches a lexeme at the current position of the source string.
     * I.e if a lexeme is present, moves the stream by the length of the lexeme.
     * @param lexeme One or more lexemes to match.
     * @param offset The offset relative to the current position.
     * @returns Whether a lexeme was matched.
     */
    match(lexeme: string | string[], offset?: number): boolean;
    /**
     * Returns the first presenting lexeme, and undefined otherwise.
     * @param lexemes Lexemes to check for.
     * @param offset The offset relative to the current position.
     */
    findPresenting(lexemes: string[], offset?: number): string | undefined;
    /**
     * Returns the first matched lexeme, and undefined otherwise.
     * @param lexemes Lexemes to match with.
     * @param offset The offset relative to the current position.
     */
    findMatching(lexemes: string[], offset?: number): string | undefined;
    /**
     * Checks whether a regex pattern exists in the rest of the source string.
     * @param regexp One or more regular expressions to test for.
     * @param offset The offset relative to the current position.
     */
    testFor(regexp: RegExp | RegExp[], offset?: number): boolean;
    /**
     * Matches a regex pattern with the rest of the source string.
     * @param regexp A regular expression to match with.
     * @param offset The offset relative to the current value.
     */
    matchRegExp(regexp: RegExp, offset?: number): RegExpMatchArray | null;
    /**
     * The {@link SourceLocation location} of the current character.
     */
    get location(): SourceLocation;
    /**
     * The line containing the current character.
     */
    get currentLine(): string;
}
