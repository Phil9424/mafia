"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const inputstream_1 = require("@4erem6a/inputstream");
/**
 * Utility class for string analysis.
 */
class InputStream extends inputstream_1.InputStream {
    /**
     * Makes a regexp match from the start of the string if it's not.
     * @param regexp A regexp to normalize.
     */
    static normalizeRegexp(regexp) {
        if (regexp.source.startsWith("^")) {
            return regexp;
        }
        return new RegExp(`^${regexp.source}`, regexp.flags);
    }
    /**
     * Tries to match a lexeme.
     * @param lexeme A lexeme or an array of lexemes to match.
     * @param offset Matching position offset.
     */
    matchLexeme(lexeme, offset) {
        if (Array.isArray(lexeme)) {
            return lexeme.some(lexeme => this.matchLexeme(lexeme, offset));
        }
        if (typeof lexeme == "string") {
            return this.match(lexeme, offset);
        }
        const match = this.matchRegExp(InputStream.normalizeRegexp(lexeme), offset);
        if (match === null || match === void 0 ? void 0 : match[0]) {
            this.move(match[0].length);
            return true;
        }
        return false;
    }
    /**
     * Looks whether a lexeme of any of lexemes is present at the current position.
     * @param lexeme A lexeme or an array of lexemes to look for.
     * @param offset Matching position offset.
     */
    lookForLexeme(lexeme, offset) {
        if (Array.isArray(lexeme)) {
            return lexeme.some(lexeme => this.lookForLexeme(lexeme, offset));
        }
        if (typeof lexeme == "string") {
            return this.lookFor(lexeme);
        }
        return this.testFor(InputStream.normalizeRegexp(lexeme), offset);
    }
    /**
     * Returns the first matching lexeme from an array or undefined.
     * @param lexemes An array of lexemes to search in.
     * @param offset Matching position offset.
     */
    findMatchingLexeme(lexemes, offset) {
        return lexemes.find(lexeme => this.matchLexeme(lexeme, offset));
    }
    /**
     * Returns the first lexeme from an array that is present at the current position.
     * @param lexemes An array of lexemes to search in.
     * @param offset Matching position offset.
     */
    findPresentingLexeme(lexemes, offset) {
        return lexemes.find(lexeme => this.lookForLexeme(lexeme, offset));
    }
    /**
     * Returns the length of a lexeme or 0 if it's not present.
     * @param lexeme A lexeme to measure.
     * @param offset Matching position offset.
     */
    measureLexeme(lexeme, offset) {
        var _a, _b;
        if (typeof lexeme == "string") {
            return this.lookFor(lexeme) ? lexeme.length : 0;
        }
        const match = this.matchRegExp(lexeme, offset);
        return (_b = (_a = match === null || match === void 0 ? void 0 : match[0]) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    }
}
exports.InputStream = InputStream;
