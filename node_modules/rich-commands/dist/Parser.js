"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const InputStream_1 = require("./InputStream");
/**
 * The flag parsing mode.
 * @ignore
 */
const FLAG_MODE = Symbol("FLAG_MODE");
/**
 * Class for parsing commands.
 */
class Parser {
    constructor(source, options) {
        /**
         * The parsing mode stack.
         */
        this.modeStack = [];
        this.source = source instanceof InputStream_1.InputStream ? source : new InputStream_1.InputStream(source);
        this.options = options;
    }
    /**
     * The current parsing mode.
     */
    get mode() {
        return this.modeStack[this.modeStack.length - 1];
    }
    /**
     * Resets the parser state.
     */
    reset() {
        this.source.reset();
    }
    /**
     * Matches the rest of the source and returns it as a string.
     */
    matchRest() {
        const rest = this.source.rest;
        this.source.move(rest.length);
        return rest;
    }
    /**
     * Tries to parse a command.
     */
    command() {
        this.skipSeparators();
        const name = this.string();
        if (!name) {
            return null;
        }
        const parts = this.commandParts();
        return { name, parts };
    }
    /**
     * Parses command parts while the source is valid and the desired part count is not reached (if set).
     * @param count Number of parts to parse.
     */
    commandParts(count) {
        const parts = [];
        while (this.source.isValid && (count == undefined || parts.length < count)) {
            const part = this.commandPart();
            if (part !== null) {
                parts.push(part);
            }
        }
        return parts;
    }
    /**
     * Tries to parse a command part.
     */
    commandPart() {
        var _a;
        this.skipSeparators();
        return this.source.isValid ? (_a = this.flag()) !== null && _a !== void 0 ? _a : this.argument() : null;
    }
    /**
     * Tries to parse a command flag.
     */
    flag() {
        var _a, _b;
        const flagMarkers = (_a = this.options.flagMarkers) !== null && _a !== void 0 ? _a : [];
        if (!this.source.matchLexeme(flagMarkers)) {
            return null;
        }
        this.skipSeparators();
        this.modeStack.push(FLAG_MODE);
        const name = this.string();
        this.modeStack.pop();
        if (!name) {
            return null;
        }
        this.skipSeparators();
        const valueMarkers = (_b = this.options.flagValueMarkers) !== null && _b !== void 0 ? _b : [];
        const value = this.source.matchLexeme(valueMarkers)
            ? (this.skipSeparators(), this.argument())
            : true;
        return { name, value: value === null ? true : value };
    }
    /**
     * Tries to parse a command argument.
     */
    argument() {
        var _a, _b;
        return (_b = (_a = this.rest()) !== null && _a !== void 0 ? _a : this.quoted()) !== null && _b !== void 0 ? _b : this.simpleOrEmpty();
    }
    /**
     * Tries to match a rest marker.
     * If matched, matches and returns the rest of the source as a string argument.
     * Otherwise, returns null.
     */
    rest() {
        var _a;
        const restMarkers = (_a = this.options.restMarkers) !== null && _a !== void 0 ? _a : [];
        if (this.source.matchLexeme(restMarkers)) {
            return this.matchRest();
        }
        return null;
    }
    /**
     * Tries to parse a string argument.
     */
    string() {
        var _a;
        return (_a = this.quoted()) !== null && _a !== void 0 ? _a : this.simple();
    }
    /**
     * Tries to parse a quoted string argument.
     */
    quoted() {
        var _a;
        const opening = this.findPresentingOpeningQuote();
        if (!opening) {
            return null;
        }
        else {
            this.source.matchLexeme(opening);
        }
        const closing = this.getClosingQuote(opening);
        let current = this.source.current;
        let buffer = "";
        const escapes = (_a = this.options.escapeMarkers) !== null && _a !== void 0 ? _a : [];
        while (!this.source.matchLexeme(closing)) {
            if (!this.source.isValid) {
                return buffer;
            }
            const escape = this.source.findPresentingLexeme(escapes);
            if (escape) {
                const escapeLength = typeof escape == "string" ? escape.length : this.source.measureLexeme(escape);
                if (this.source.matchLexeme(closing, escapeLength)) {
                    buffer += closing;
                    this.source.move(-1);
                }
                else if (this.source.matchLexeme(escape, escapeLength)) {
                    buffer += escape;
                    this.source.move(-1);
                }
                else {
                    buffer += current;
                }
            }
            else {
                buffer += current;
            }
            current = this.source.next;
            this.source.move(1);
        }
        return buffer;
    }
    /**
     * Tries to parse a simple or an empty argument.
     */
    simpleOrEmpty() {
        var _a;
        const emptyMarkers = (_a = this.options.emptyArgMarkers) !== null && _a !== void 0 ? _a : [];
        const simple = this.simple();
        return simple && emptyMarkers.includes(simple) ? undefined : simple;
    }
    /**
     * Tries to parse a simple string argument (anything which is not a marker).
     */
    simple() {
        var _a, _b;
        const separators = (_a = this.options.separators) !== null && _a !== void 0 ? _a : [];
        const valueMarkers = (_b = this.options.flagValueMarkers) !== null && _b !== void 0 ? _b : [];
        let current = this.source.current;
        let buffer = "";
        while (this.source.isValid &&
            !this.source.matchLexeme(separators) &&
            !this.findPresentingOpeningQuote()) {
            if (this.mode == FLAG_MODE && this.source.lookForLexeme(valueMarkers)) {
                break;
            }
            buffer += current;
            current = this.source.next;
            this.source.move(1);
        }
        return buffer || null;
    }
    /**
     * Returns the corresponding closing quote for the opening one.
     * @param opening The opening quote.
     */
    getClosingQuote(opening) {
        var _a;
        const quotes = (_a = this.options.quotes) !== null && _a !== void 0 ? _a : [];
        const closingQuote = quotes.find(q => {
            q = Array.isArray(q) ? q[0] : q;
            return q == opening;
        });
        return Array.isArray(closingQuote) ? closingQuote[1] : closingQuote;
    }
    /**
     * Returns the opening quote presented at the current source position, if any.
     */
    findPresentingOpeningQuote() {
        var _a;
        const quotes = (_a = this.options.quotes) !== null && _a !== void 0 ? _a : [];
        const openingQuotes = quotes.map(q => (Array.isArray(q) ? q[0] : q));
        return this.source.findPresentingLexeme(openingQuotes);
    }
    /**
     * Skips all subsequent separators.
     */
    skipSeparators() {
        var _a;
        const separators = (_a = this.options.separators) !== null && _a !== void 0 ? _a : [];
        while (this.source.matchLexeme(separators))
            ;
    }
}
exports.Parser = Parser;
